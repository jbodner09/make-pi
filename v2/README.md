# Version 2: Updated in 2015, in `make_pi_2.c`

I've used this code for 5 years now, and it's always bothered me that the limiting resource is memory space.  Although my original reason for storing all my intermediate results was so that each step in the process was immediately visible, in general, it's not good coding practice to make RAM the limiting component of a program.  Usually, a good operating system will limit the amount of RAM that any single program can request within a short amount of time, and since the amount of RAM we have is pretty much unchangeable on an immediate basis, you want to instead make the limiting factor in any program the amount of time it takes to execute.  

We can always request more CPU time, since CPU resources, although limited in the number of operations they can perform per second, are technically infinite over time.  At that point, it becomes an exercise of patience and precision.  We can now request as many iterations as we want to wait on, but there is unfortunately another factor that limits the precision of our results.  Internally, the computer has to use a finite number of bits to store each of the intermediate results that we calculate.  Most of these numbers are not integers, and their fractional part repeats forever.  Since we can't store an infinite number in a finite amount of space, this means that at some point, we will have to chop off part of the number.  

This chopping off is what is referred to as a loss of precision.  If you keep using those same chopped-off numbers over and over, the amount of error you get in your overall calculations will continue to build and build.  So, the precision to which we calculate pi is now unfortunately limited by the way we store each of these intermediate results.  This sort of problem is much more difficult to overcome using standard programming languages.  Although I made minor updates to use the biggest numbers I possibly could, our precision is still limited to about 12 decimal places for our final result.  No matter how many more iterations you take the code out to, your answer will still only be accurate to about 12 places.  

My main goal to make RAM no longer the limiting factor was met, though.  In theory, you can now do 2,000,000 iterations instead of 20,000 if you want to.  You'll obviously have to wait longer (the computation will actually take a perceivable amount of time once you reach about 1,000,000), but it won't crash your machine by using up all its memory.  The bigger point, though, is that you don't need to take it out past 2,000,000 iterations, since at that point, the limited internal precision of the intermediate results will make it so that the error we accumulate will prevent us from making our end value of pi more precise.  

One other major update I made was to increase the parallelism of the code.  To get rid of all those stored intermediate results that were hogging memory, I had to move all the calculations into a single loop, which was easy to do since each intermediate result was not dependent on any result before it.  Now, we create one partial sum per loop iteration.  Because each loop iteration stands alone and can create its partial sum without worrying about what any other iteration does, it seems natural that we can actually have multiple loop iterations executing on multiple processors at the same time.  Each processor will thus perform a distinct subset of the total number of iterations, and then the partial results from each processor can be combined in the end for the overall result.  

This form of parallelism is very natural nowadays, since even our phones have multi-core processors.  In my implementation, I used threading, where the main program initially contains only a master thread, and then it spawns off temporary worker threads whose only job is to perform loop iterations.  After all the workers are done, the master thread then gathers all the partial results from the workers and outputs the final result.  Since C contains no native multithreading support, I used the POSIX pthread library, which means the code below is supported only on Linux/Unix.  However, worry not Windows users, I also provided C, C#, and Java versions that are built specifically for us!  

A few other small changes that are noteworthy:  the number of iterations to perform and the number of threads to use are now taken as command-line arguments to the program.   This means they can be different every time you run the program if you want!  Before, I had the value hard-coded, so you had to re-compile every time you changed it.  You should be aware that most operating systems limit the number of threads you can create, so even if you want a huge number of threads, you may not get them.  Additionally, you'll probably see worse performance if you ask for more threads than you have processors or cores in your computer.  This is because multiple threads will then have to share a single core, and they won't just go one after the other.  Instead, they'll switch off multiple times every second to try to be fair to each other, and that switching costs extra time.  

Next, I added a crude timing feature so that you actually know how much time your computation took.  Finally, you'll notice that the actual calculation was moved into a separate function.  This is because each thread executes a specific function.  When we create multiple processes, each process continues execution precisely where it was split.  Threads, though, only operate out of a single processes, so they're somewhat limited in their capability.  Man, just look at how much more complex this new code is compared to the original!  If that isn't a sign of how much I've grown as a programmer, I don't know what is.

## Version 2.1: Showing Microsoft some love, in `WinPi.cpp`

Here is the version for Windows that uses the native Win32 threading API.  Windows is an interesting beast, because it doesn't come with a native C compiler that you can just run from the command line.  You'll need an external one, such as the compiler in Visual Studio.  Copying this code into Visual Studio isn't too big of a deal, and other than changing a few signatures of functions, the code is almost identical to the Linux code.  The biggest thing to worry about is Visual Studio itself:  it will want to do weird things like use Unicode characters, which can screw up your command line arguments if you're not careful (I MAY have spent over an hour trying to figure that one out), so you'll need to make sure you change that in the project settings.

## Version 2.2: Yeah, lots of love, in `Program.cs`

Now for the exciting part:  more ports!  After porting this to Windows, I thought, "Why stop there?"  We should have some COMPLETELY platform agnostic implementations!  So, I chose two languages that can provide that:  C\# (which you all know is my favorite language for a variety of reasons), and Java (because it was really, really easy to port between it and C\#).  

The biggest difference now, besides having to wrap everything in classes, is that we finally have native threading support.  Of course, each language treats threading a little differently.  In C\#, threads are explicit classes that you can just call start and stop methods on.  Error checking is a little easier, since we have try/catch blocks for exceptions.  The only other major difference is now that the arguments have their own class that they're wrapped in.  In fact, the thread calculation is just a method within that class.  And, since we no longer have global scope, each instance of the class holds on to its result for the main calling thread to get back.  Really, it's quite elegant, and overall less verbose than the straight C code.  

To build it, you'll just need to throw it in a new C\# project in Visual Studio (since compiling CLR code from the command line is a little tricky).  But to run it, you can just run it like all the others:  call the name of the program and give it the two expected arguments.  

## Version 2.3: Slightly less love, in `Program.java` and `Calculation.java`

In Java, threads don't have a separate class.  Instead, any class can be an instance of a thread just by extending the base Thread class and overriding the built-in run() function.  This is a very trivial change from C\#, since it also requires a separate class from the main Program class.  Java likes classes in separate files, though, so compilation may require multiple steps.  The good news is that you don't have to create a project in an IDE since you can compile Java from the command line!  What's interesting to see is how Java handles precision error a little differently from the other languages, so the results here might be slightly different than in other languages.  
